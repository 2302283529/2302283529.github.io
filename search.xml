<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[市政【党群管理系统】分析，]]></title>
    <url>%2F2018%2F11%2F14%2FCMMProject%2FCMMProject%2F</url>
    <content type="text"><![CDATA[党群管理系统程序分析: ★★★★★★★★★★★★★★★★★★★★★★ 1. CMM系统背景 ★★★★★★★★★★★★★★★★★★★★ CMM主要是对上海隧道股份市政集团进行党员的管理，党员的调动，党员的形成，党费的申请和核销，进行处理的，三会一课的记录分析，可以提高人员的工作效率，方便记录，CMM系统算是小白开发的第二个项目。项目大约前前后后2个月左右，今天开始，已经正式上线，小白还是比较开心的，项目整体来说，比较满意，从项目的底层编写和修改，到业务逻辑的处理，界面的展示的效果已经完成。如果有兴趣的可以看看小白接下来的功能介绍。 CMM功能组成模块: 1.0系统管理 组织管理: 1.主要功能+部门、+岗位、修改、封存、启用、取消选中、查询，打印 2.解释一下，组织管理是CMM是核心，主要里面的任何操作同步的SAM,由SMA对每个人党员进行权限分配，管理。组组结构与树形结构为主，方便显示和展示。 系统日志: 1.主要功能查看。 2.等要是看看那些人，什么时候登陆系统，操作了什么样的数据，进行记录，方便数据有被误删的风险，方便恢复。 数据字典: 1.主要功能新增、修改、查看、删除。，打印 2.数据字典主要是让用自己添加下拉选项，方便用户进行选择，和填写。可以把数据字典看成一个库，一个可以容纳所有选项的库。 字典类型: 1.主要功能新增、修改、查看、删除。，打印 2.字典类型主要是给数据字典进行分类整理，对数据字典的数据进行梳理。 1.1党建： 基本信息: 1.主要新增、修改、查看、删除,高级查询。，打印 2.主要是接受HR人力资源党员发展里面同步进来的数据，进行展示，查看页面是这人的党员，个人基本信息介绍，行政岗位，党组织信息，什么时候申请入党，什么时候成为积极分子，等等。一系列化的流程状态，使CMM更加正规，打破传统的新模式，新思路。 党员调动： 1.主要新增、修改、查看、删除,高级查询。发起流程，打印 2.党员调动主要是由那一个组织，调动到那一个组织，进行党员的变更。数据同步，和消息的通知。这里的的消息通知使用的公司的任务调动。 组织信息: 1.只有查看页面。 2.主要是展示这个组织下面有多少人，分别是那些，然后组织的负责人是谁，上级是什么组织，人的姓名使用笔画排序。 党费管理: 1.主要新增、修改、查看、删除、流程图、核销、高级查询，打印 2.主要是对党支部组织的使用的费用进行记录，并且申请核销。好在年底的时候进行对账。 三会一课: 1.主要新增、修改、查看、删除,导出，打印 2.主要是对党校的会议进行记录分析，那些党组织最近做了什么事情,那些内容，完成那些，让后展示为报表进行查看。 三会一课: 1.主要新增、修改、查看、删除,导出，打印，换届选举 2.主要是对党组织上的干部进行选举，需要参考选举人的政集怎么样，推荐人是那些，进行选举。经过一系列的流程审批，进行判定,是否判断选举。 CMM效果展示图: 2.0首页效果图 这里的效果主要是展示出登陆的人代办任务和已办任务的处理，功能权限的展示，每个人的登陆的权限是不一样的，权限有SMA配置。 2.1系统配置–组织信息 SAM对与CMM权限的控制，主要以组织架构为主,组织信息的展示，后台对SAM有进行对接口，进行数据的传输。 CMM代码展示图: 3.0javaScript的展示 注：如果有不理解的给我联系小白。一起学习和交流。 3.1C#后台代码展示 注：如果有不理解的给我联系小白。一起学习和交流。 3.2分享一个小知识点。怎么不理解看别人的代码，例如: 在项目时间充足的情况，遇到别人写的乱乱的代码的时候，还没有备注的情况下，看另名也没规范的话，请先静下心来，开始准备接下来的功课之旅，你会发现，心里面面一万句操你玛出现，这个时候需要冷静，冷静，然后看看周围有没有是不是的搬砖，去勿死他，勿死他，写的什么鬼东西啊，备注都没的。格式也没法整理，另明随便写的。相信没个人都有这样的经历吧，小白也不例外，小白还想分享给大家一句话：得知使然，失知嫣然 记好了：我们年轻，前途不好限量，加油！元气慢慢的一天 项目部署须知: 4.2资源管理： 数据库: 1.对数据库最好进行详细的整理，即项目表的创建,存储过程的迁移工作。 2.程序Config配置文件的连接字符串进行修改。 程序的运行: 1.我的环境是.NET Framework4.6的环境变量，需要百度下载，进行安装就可以了。 端口号的问题: 1.控制面板==&gt;防火墙==&gt;高级设置==&gt;入站规则==&gt;新建规则==&gt;选择端口==&gt;不想麻烦的话（选择Tcp）==&gt;填写端口号==&gt;选中永许连接==&gt;然后全选==&gt;输入名称==&gt;点击完成，这样的端口号就建立好了。 2.在IIS发布里面选中你刚才所配置的端口，就可以访问了。 导入所遇到的坑: 1.在IIS里面的应用程序池里面找到你所建立的网站，点击右键选中高级设置，启用32位应用程序改成True。 2.在服务器里面安装AccessDatabaseEngine这个环境变量即可,如果有遇到其他问题的，无法解决的，欢迎联系小白。一起共同进步。 CMM项目心得: 1.刚接触这个项目的时候，小宝还是很抵触的，应为这个项目是1年多以前的开发的，需要对接sso,还有我们姜哥很牛逼的流程图，还有后台底层代码，都有一种万恋剧灰的感觉，各种js，不同的混合版本，总之一句会，就是让你看不懂，还没办法，他就是能实现功能。 2.当我接触CMM,看到过乱七八糟的底层代码的时候，心有一种什么鬼东西啊，其实没个人都有一种，你越害怕的东西，他越会出现，小白就这样险入其中了，没办法，当我接手这个项目的时候，我只能做好，因为我是新人，没办法，我只有足够的努力，才能完成，到现在不也不知道加了多少班，没计算过，还是要感谢一个，我们公司的大神，他教会了我很多东西，大神是一个很能抬杠的人，反正就两字，牛逼。 3.今天为止，CMM进过测试，文档的调试与调整，已经过了，很激动，其实对程序员来说，每一个程序，都是自己心血的结晶，每个程序员，都希望自己的程序接近完美，可是客户不应许的啊，这个就是尴尬点了，我们只能结合客户的需要，来让自己写的程序尽量完美。 4.小白最近很喜欢刘同的一本书”我在未来等你”。小白很喜欢一句话：“一个拼尽全力的人能做成很多事情，但首先你起码要证明你能为一件事拼命!” 5.愿你平生一腔孤勇，直到我能护你周全，晚安 送上一句晚安心语: 【再遇到喜欢的人，想来只觉得非常遗憾，早几年遇见就好了。那些热烈、欢喜、年少轻狂和桀骜不驯，连同整个世界都要送给你，可你来得太晚了。我已经学会了一个人送走落日等待星光，我的爱早在无数个孤立无援的时刻里，变得有了计较和盘算，再也没有曾经的纯粹】]]></content>
      <categories>
        <category>实体项目</category>
      </categories>
      <tags>
        <tag>实体项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员专用离职信]]></title>
    <url>%2F2018%2F11%2F08%2FProgrammerTips%2FResignationLetter%2F</url>
    <content type="text"><![CDATA[程序员专用离职信: 程序员每个人都会遇到离职的时候，所以小白推荐大家用的离职书，堪称为经典。呜呜呜，嗷嗷嗷！ 辞职信NO1： 尊敬的公司领导: 此时辞呈，敬请海涵。 当初公司募才纳新，未嫌我才疏学浅，承蒙收容。入职以来，领导 厚爱，同事相亲，至今心怀感念，不敢稍有遣忘。 勤心劳作，不求闻达富贵，薪酬所愿，只需温饱残喘，欲效犬马，以图恩报。 时至今日，事与愿违，本当坚持，然孝亲养身，责任在肩，今日请辞，实属无奈，提携之恩，栽培之情，铭记五内，永吾所愿人生有时，必当回报！ 续聘人手，亦须时日，一月之内，必当坚守！ 词不达意，尚析见谅！ 辞职人：向勇 2018年11月8日 原因：人脸闸机，问题存在，历史不复当初，加班依然不在。心态以没，代码不出，头发以掉，人脸一脱。辞职信NO2: 尊敬的公司领导: 值此用人之际，不期请辞,实属不敬。 历经四季，余已凡才，承蒙殊遇。幸受公司各领导知遇知恩，得以 与诸位贤达共事。 时光荏苒，吾经竭力而为，以图报效，虽幸遇领导恩教，然资质愚钝，图添麻烦，每思于此， 未尝不惶恐叹息，吾有所长，终难掩寸之短。 思之在三，恐吾业太深，与司与己，皆无义可言，遂决意就此辞去。 一朝共事，终身莫逆，暂别之后，他日或幸遇山水之间，余当执壶悲殇，与君等邀月共饮，谈笑江湖！ 又诉离殇，执笔涕零，临纸神驰，不尽欲言，只惟愿诸君同仁，飞黄腾达，再铸辉煌， 辞职人：向勇 2018年11月8日 原因：人脸闸机，问题存在，历史不复当初，加班依然不在。心态以没，代码不出，头发以掉，人脸一脱。]]></content>
      <categories>
        <category>程序员心得体会</category>
      </categories>
      <tags>
        <tag>程序员心得体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql server --Case When then else使用]]></title>
    <url>%2F2018%2F11%2F08%2FSQL%20Server%2FConversion%2F</url>
    <content type="text"><![CDATA[Case When then else函数说明: 函数寓意为行列转换的过程，很想三元运算符的思路。有不懂的小伙伴可以私聊我，最近小宝毕竟忙，博客会更新的比较慢，望见谅！ 例如: select row_number() OVER(ORDER BY [User].ID) as 编号, //按照User.ID进行排序 UID as 用户编号, Name as 姓名, max(case ScoreName when ‘英语’ then Score else 0 end) 英语, //判断ScoreName等于英语的情况下，返回为Score的值 否则为0 max(case ScoreName when ‘数学’ then Score else 0 end) 数学 //判断ScoreName等于数学的情况下，返回为Score的值 否则为0 from Score,[User] WHERE Score.UID=[User].ID group by UID,[User].ID,Name //然后进行分组。按照两种ID进行分组 业务功能:需要根据最近的功能进行不同的调整。如果你是初学者，建议最好不要复制，因为代码的世界，是需要自己一点一点的积累。少年加油，愿你走出半生，归来仍是少年！ 送上一句晚安心语:【放弃与放手的区别：放弃是牺牲本来属于你的，放手是放下那些从来不是你的。】]]></content>
      <categories>
        <category>Sql server</category>
      </categories>
      <tags>
        <tag>Sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PIM大通系统分析，]]></title>
    <url>%2F2018%2F10%2F31%2FPIMProject%2FBusinessneeds%2F</url>
    <content type="text"><![CDATA[PIM系统程序分析: ★★★★★★★★★★★★★★★★★★★★★★ 1. PIM系统背景 ★★★★★★★★★★★★★★★★★★★★ PIM主要是针对人脸闸机进行开发的，辅助性项目，对人脸闸机人员实名制的发布，多图片的上传，单位管理，人员所属类型的分配，主要是一种进行仓库式管理的系统方案。小白是这样项目的创建者，也是开发者，后期维护者。今天主要的目的，是详细介绍PIM系统的功能模块，和代码展示，可以共于学习。对小白的成长，进行记录。话不多少，如下， PIM功能组成模块: 1.0人员实名制管理 人员实名制登记: 1.主要功能新增、修改、查看、删除、导入、导出、注册IC卡、批量上传图片、高级查询 2.解释一下批量上传图片的意义,主要更具上传图片的分配到每个人，图片必须以身份证来匿名，根据小白的不断调试，上传图片因为要满足人脸闸机设备，图片不能大于200kb,小宝一次需要上传几百张图片然后根据图片分配到每个人，大约时间为10秒左右，有动画加载。 hex 单位管理: 1.主要功能新增、修改、查看、删除。 2.实现人员实名制登记里面的所属单位，建立的一个单位库。。 人员类型管理: 1.主要功能新增、修改、查看、删除。 2.协调单位管理，让人员实名制登记里面的所属单位和所属类型形成一个二级联动。以满足客户需要为主。 1.1人员进行管理： 人员进出记录: 1.主要新增、修改、查看、删除。 2.主要是接送人脸闸机同步发过来人员的进出记录的数据，进行展示。 1.2资源管理： 工厂管理: 1.主要新增、修改、查看、删除。 2.主要是登记公司所属工厂的记录，方便了解人脸闸机所属那个工厂。 道闸管理: 1.主要新增、修改、查看、删除。 2.主要是对人脸闸机的登记记录，分为三滚闸机、螺旋闸等。 人脸设备管理: 1.主要新增、修改、查看、删除。 2.主要是登记设备的IP、端口号，以工厂为中心，道闸分布，形成设备管理的二级联动。进行数据操作。 PIM效果展示图: 2.0批量导入效果图片 这里的效果主要实现多文件异步上传，然后分配到对应的人员。将图片发送给人脸闸机。 注：如果有不懂人脸闸机的，可以比喻成地铁站里面的那个出站口，一个是刷卡，一个是刷脸的。 2.1导入效果图片 这里的导入主要是以身份证号进行导入，有相同的身份证号进行修改。导入成功是返回导入的数量，更新的数据，报错的数据，第几天出现问题。 2.2导入效果图片 这里主要使用是Epplus进行导入，如果不会Epplus的可以百度，小白这里也有一份自己改装过后的导出帮助类，可以直接使用。 PIM代码展示图: 3.0javaScript的展示 注：如果有不理解的给我联系小白。一起学习和交流。 3.1C#后台代码展示 注：如果有不理解的给我联系小白。一起学习和交流。 3.2分享一个小知识点。怎么样解析读取一个json文件 string strReadFilePath = &quot;D:\\prm\\RNS.WebClient\\Content\\PIM.json&quot;; StreamReader srReadFile = new StreamReader(strReadFilePath); string jsonText = &quot;&quot;; while (!srReadFile.EndOfStream) { jsonText += srReadFile.ReadLine(); } Object jo = (JObject)JsonConvert.DeserializeObject(jsonText); var returnValue = jo.ToJson(); 项目部署须知: 4.2资源管理： 数据库: 1.对数据库最好进行详细的整理，即项目表的创建,存储过程的迁移工作。 2.程序Config配置文件的连接字符串进行修改。 程序的运行: 1.我的环境是.NET Framework4.6的环境变量，需要百度下载，进行安装就可以了。 端口号的问题: 1.控制面板==&gt;防火墙==&gt;高级设置==&gt;入站规则==&gt;新建规则==&gt;选择端口==&gt;不想麻烦的话（选择Tcp）==&gt;填写端口号==&gt;选中永许连接==&gt;然后全选==&gt;输入名称==&gt;点击完成，这样的端口号就建立好了。 2.在IIS发布里面选中你刚才所配置的端口，就可以访问了。 导入所遇到的坑: 1.在IIS里面的应用程序池里面找到你所建立的网站，点击右键选中高级设置，启用32位应用程序改成True。 2.在服务器里面安装AccessDatabaseEngine这个环境变量即可,如果有遇到其他问题的，无法解决的，欢迎联系小白。一起共同进步。 PIM项目心得: 1.刚接触的时候以为这个项目很简单，开发周期也不会很常，经历时间大概15天，小白是一个特别喜欢编程的人，特别去喜欢研究新的知识点，这样项目不大，却是小白工作以来第一个完整上线的项目，很有意义。 2.小白想告诉新手，编程是一件很枯燥烦闷的事情，如果你对编辑没有兴趣，还是不要进入，很多事情并没有想像中的那么好，编程一样。不要想像微微一笑很清晨那个，你很快会发现牛逼的也就那么几个人，小白是一个不喜欢幻想的人，脚踏实地的去做事，去完成。 3.如果你工作当中能碰到一个好的贵人，恭喜你很幸运，我也很幸运，在上海**公司，遇到了一个可以告诫自己，有会提醒你的人。在工作当中如果你一旦堕落，会变成别人眼中的Oldoilstrip 。 4.加油少年，未来的人，会感谢你现在的挣扎。 5.祝:路过的女孩子，阳光，可爱，漂亮，手上有钱，心里有我，请留下你的联系方式，或者联系我。(嘟嘟) 小白PIM项目源码:因文件过大，如果需要源码的可以联系小白！ 送上一句晚安心语: 【人生注定负重登山，攀高峰，陷低谷，处逆境，一波三折是人生之必然，不可能倒霉一辈子，山穷水尽疑无路，柳明花暗又一村，忍着忍着就面对了，挺着挺着就承受了，走着走着就过去了。一切的坎坷只是暂时的，找到解决问题的切入点，坎坷会使我们更成熟，更完美，更坚强地撑起自己的一片心灵天空。晚安~】]]></content>
      <categories>
        <category>实体项目</category>
      </categories>
      <tags>
        <tag>实体项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql server --触发器]]></title>
    <url>%2F2018%2F10%2F11%2FSQL%20Server%2FTrigger%2F</url>
    <content type="text"><![CDATA[概念:触发器是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，当对一个表进行操作(Insert,delete,update)时就会激活它执行，触发器经常用于加强数据完整性约束和业务规则等。触发器可以从DBA_TRIGGers,USER_TRIGGERS数据字典种查到。 触发器和存储过程的区别: 触发器与存储过程的区别是运行方式的不同，触发器不能执行EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发执行而存储过程需要用户，应用程序或者触发器来显示地调用并执行。触法器的优点: 1.触发器是自动，当对表中的数据做了任何修改之后立即被激活。 2.触发器可以通过数据库中的相关表进行层叠修改。 3.触发器可以强制限制，这些限制比用CHECHK约束所定义的更复杂。与CHECHK约束不同的是触发器可以引用其他表中的列。 触发器的作用: 触发器的主要作用就是其能够实现由主键和外键所不能保证的复杂参照完整性和数据的一致性，它能够对数据库中的相关表进行级联修改，提高比CHECK约束更复杂的的数据完整性，并自定义错误消息。触发器的主要作用主要有以下接个方面： 1.强制数据库间的引用完整性 2.级联修改数据库中所有相关的表，自动触发其它与之相关的操作 3.跟踪变化，撤销或回滚违法操作，防止非法修改数据 4.返回自定义的错误消息，约束无法返回信息，而触发器可以 5.触发器可以调用更多的存储过程 触发器的工作原理: 1.系统自动在内存中创建deleted表或inserted表； 2.只读，不允许修改，触发器执行完成后，自动删除。 inserted表： 1.临时保存了插入或更新后的记录行； 2.可以从inserted表中检查插入的数据是否满足业务需求； 3.如果不满足，则向用户发送报告错误消息，并回滚插入操作。 deleted表： 1.临时保存了删除或更新前的记录行； 2.可以从deleted表中检查被删除的数据是否满足业务需求； 3.如果不满足，则向用户报告错误消息，并回滚插入操作 例如:创建insert触发器: --创建一个触发器 create trigger trig_insert --来自于那张表 on student --什么操作 after insert as begin if object_id(N&apos;student_sum&apos;,N&apos;U&apos;) is null--判断student_sum表是否存在 create table student_sum(stuCount int default(0));--创建存储学生人数的student_sum表 declare @stuNumber int; select @stuNumber = count(*)from student; if not exists (select * from student_sum)--判断表中是否有记录 insert into student_sum values(0); update student_sum set stuCount =@stuNumber; --把更新后总的学生数插入到student_sum表中 end 送上一句晚安心语: 【当你培养了不可撼动的自信，你的整个世界都会变得更好。】]]></content>
      <categories>
        <category>Sql server</category>
      </categories>
      <tags>
        <tag>Sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql server --存储过程的使用]]></title>
    <url>%2F2018%2F10%2F09%2FSQL%20Server%2FStoredprocedure%2F</url>
    <content type="text"><![CDATA[存储过程的优点: 1.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 2.当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。 3.存储过程可以重复使用,可减少数据库开发人员的工作量 4.安全性高,可设定只有某此用户才具有对指定存储过程的使用权 缺点: 1.如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则您仍需要更新程序集中的代码以添加参数、更新 GetValue() 调 用，等等，这时候估计比较繁琐了。 2.可移植性差、由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。 3.在小白眼中存储过程分为两种，一种是有业务支撑，一种是无业务支持的。接下来，小白会为大家举例说明： 例1：无业务支撑: --判断存储过程是否存在 if exists(select * from sysobjects where name=&apos;Sys_Relation&apos;) --存在着删除 drop procedure Sys_Relation go --创建存在过程 create procedure Sys_Relation --传的参数 @num int as --业务逻辑 print &apos;参加&apos;+convert(varchar(5),@num)+&apos;门课考试的学生姓名及学号:&apos; select 姓名=(select MName from Member where MID=Score.MID),学号=MID from Score group by MID having count(*)=@num --调用存储过程-- exec Sys_Relation @num=2 这个主要是控制输入几门课考试的学生姓名及学号，当传的参数是2这，考两门课考试的学生姓名及学号。依此内推。上述是一个简单的存在过程，主要作用是了解，存在过程的思想和应用。希望初学者可以好好体会，我们都是这样的过来的。如果有一个好的师傅带，应该会学的快一些。如果有兴趣拜师的，可以联系我。 例1：有业务支撑: – ============================================= – 作者: LB – 创建日期: – 说明: &lt;安全文明分级处置开单数报表&gt; – ============================================= ALTER PROCEDURE [dbo].[sz_spSecurityCorrReport] @year_month varchar(20), --年月2016-10 @search_type char(1), --查询条件 1:按姓名查询 2:按分公司查询 @content varchar(20) --条件查询 AS BEGIN declare @sql nvarchar(max) if(@search_type != &apos;2&apos;) --按人员姓名查询 begin set @sql = &apos;SELECT 名称, ISNULL(整改单, 0) + ISNULL(告知单, 0) + ISNULL(约谈单, 0) AS 开单数, 整改单, 告知单, 约谈单, 管理, 机械设备, 用电, 安全设施, 个人防护用品, 其他, 重大危险源 FROM (SELECT b.name AS 名称, (SELECT COUNT(1) FROM sz_SecurityCorr WHERE del = 0 AND startEventLevel = 1 AND approveStatus = &apos;&apos;2&apos;&apos; AND creatorId = a.account_id&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10),createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 整改单,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr WHERE del = 0 AND startEventLevel = 2 AND approveStatus = &apos;&apos;2&apos;&apos; AND creatorId = a.account_id&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10),createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 告知单,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorrIterview WHERE del = 0 AND startEventLevel = 3 AND approveStatus = &apos;&apos;2&apos;&apos; AND creatorId = a.account_id&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10),createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 约谈单,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;管理&apos;&apos; AND g.creatorId = a.account_id AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 管理,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;机械设备&apos;&apos; AND g.creatorId = a.account_id AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 机械设备,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;用电&apos;&apos; AND g.creatorId = a.account_id AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 用电,&apos; set @sql += &apos;(SELECT COUNT(1)FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;安全设施&apos;&apos; AND g.creatorId = a.account_id AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 安全设施,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;个人防护用品&apos;&apos; AND g.creatorId = a.account_id AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 个人防护用品,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;其他&apos;&apos; AND g.creatorId = a.account_id AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 其他,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND (h.checkType = &apos;&apos;重大危险源&apos;&apos;) AND g.creatorId = a.account_id AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 重大危险源&apos; set @sql += &apos; FROM OM_Rel_Account_Role AS a LEFT JOIN OM_Account AS b ON a.account_id = b.sysId&apos; set @sql += &apos; WHERE a.role_id = &apos;&apos;9aed06bffad746dcb06ee4208f151ac9&apos;&apos; and b.name like &apos;&apos;%&apos; + @content + &apos;%&apos;&apos;) AS tab&apos; end else if(@search_type = &apos;2&apos;) begin set @sql = &apos;SELECT 名称, ISNULL(整改单, 0) + ISNULL(告知单, 0) + ISNULL(约谈单, 0) AS 开单数, 整改单, 告知单, 约谈单, 管理, 机械设备, 用电, 安全设施, 个人防护用品, 其他, 重大危险源 FROM (SELECT dept.name AS 名称, (SELECT COUNT(1) FROM sz_SecurityCorr a WHERE del = 0 AND startEventLevel = 1 AND approveStatus = &apos;&apos;2&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = a.projectId) = dept.sysId)&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10),createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 整改单,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr a WHERE del = 0 AND startEventLevel = 2 AND approveStatus = &apos;&apos;2&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = a.projectId) = dept.sysId)&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10),createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 告知单,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorrIterview a WHERE del = 0 AND startEventLevel = 3 AND approveStatus = &apos;&apos;2&apos;&apos; and (jcdwId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = a.projectId) = dept.sysId)&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10),createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 约谈单,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;管理&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = g.projectId) = dept.sysId) AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 管理,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;机械设备&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = g.projectId) = dept.sysId) AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 机械设备,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;用电&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = g.projectId) = dept.sysId) AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 用电,&apos; set @sql += &apos;(SELECT COUNT(1)FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;安全设施&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = g.projectId) = dept.sysId) AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 安全设施,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;个人防护用品&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = g.projectId) = dept.sysId) AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 个人防护用品,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND h.checkType = &apos;&apos;其他&apos;&apos; and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = g.projectId) = dept.sysId) AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 其他,&apos; set @sql += &apos;(SELECT COUNT(1) FROM sz_SecurityCorr AS g INNER JOIN sz_SecurityCorrContent AS h ON g.sysId = h.FKID WHERE g.del = 0 AND h.del = 0 AND (h.checkType = &apos;&apos;重大危险源&apos;&apos;) and (branchCompanyId= dept.sysId or (select p.branchCompany from project_Project p where p.sysId = g.projectId) = dept.sysId) AND g.approveStatus = &apos;&apos;2&apos;&apos;&apos; if(@year_month != &apos;&apos;) set @sql += &apos; and SUBSTRING(CONVERT(varchar(10), g.createdDate, 120), 1,7) = &apos;&apos;&apos; + @year_month + &apos;&apos;&apos;&apos; set @sql += &apos;) AS 重大危险源&apos; set @sql += &apos; FROM OM_Department dept inner join sz_SecurityCorrCompany company on dept.sysId = company.companyId&apos; set @sql += &apos; where dept.del = 0 and dept.name like &apos;&apos;%&apos; + @content + &apos;%&apos;&apos;) AS tab&apos; end print @sql exec sp_executesql @sql END 这个主要是为了展示显示的数据，和客户需要看到的数据架构。 送上一句晚安心语:【没有那么多原因，一个人不喜欢你，不在乎你了，才会难得理你，消息只回复几个字，一副爱理不理的样子，什么忙不忙全都是谎言了。】]]></content>
      <categories>
        <category>Sql server</category>
      </categories>
      <tags>
        <tag>Sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号量机制---线程池相关实现，]]></title>
    <url>%2F2018%2F09%2F20%2FThread%2FRelatedExperiments%2F</url>
    <content type="text"><![CDATA[信号量机制: ★★★★★★★★★★★★★★★★★★★★★★ 1. ThreadPool使用情况 ★★★★★★★★★★★★★★★★★★★★ 其实“ThreadPool”就是用了存放“线程”的对象池。 在多线程编程中，线程的创建和销毁是非常消耗系统资源的，因此，C#引入了池的概念，类似的还有数据库连接池，这样，维护一个池，池内维护的一些线程，需要的时候从池中取出来，不需要的时候放回去，这样就避免了重复创建和销毁线程。 个人理解:托管的线程队列,管理线程队列的容器，像你经常喝水的杯子来承载你需要喝的水。 CLR线程池: 在.NET中，CLR线程和操作系统线程对应，您可以简单地认为.NET中的Thread对象便封装了一个操作系统线程，并附带一些托管环境下所需要的数据(如GC Handle)。而CLR线程池便是存放这些CLR线程的对象池。我们在编写程序的时候，可以使用ThreadPool类的两个静态方法：QueueUserWorkItem和UnsafeUserQueueWorkItem向CLR线程池中添加任务(一个WorkCallback委托对象)，这两个方法的区别，在与前者会收集调用方的ExecutionContext,也就是保留了的当前线程的执行信息(如认证或语言文化等)，使任务最终会在“创建”时刻的环境中执行–后者就不会。因此，如果比较两个方法的绝对性能，Unsafa方法会略胜一筹。但是平时还是建议使用QueueUserWorkltem方法，因为保留执行上下会避免很多麻烦事情，且这点性能耗损其实算不上什么。 CLR线程池在.NET框架中的作用很大，除了让程序员使用之外，其他一些功能也会依赖CLR线程池，如ThreadPool.RegisterWaitForSingleObject方法，或是System.Threading组件–还有更重要可能也是更隐藏的；ASP.NET在得到一个请求后，也会将这个请求处理的任务交由CLR线程池去执行–请注意，它们最多只是添加任务而已，并不表示任务会立即执行，所有添加到CLR线程池的任务都会在合适的时候得以执行–可能马上，也可能稍等片刻，甚至更久。向CLR线程池添加任务时，任务会被临时放到一个队列中，并在合适的时候执行。那么怎么样才算是“合适的时候”？简单的概括说来，便是线程池内有空闲的线程，或线程池所管理的线程数量还没有达到上限的时候。如果有空闲的线程，线程池就会立即让它领取一个任务执行。如果是第二种情况，线程池便会创建新的Thread对象。由于让操作系统管理太多线程反而会造成性能下降，因此CLR线程池会有一个上限。不同的托管环境会设置不同的上限。如在.NET 2.0 SP1之后，普通的Windows应用程序（如控制台或WinForm/WPF），会将其设置为“处理器数 * 250”。也就是说，如果您的机器为2个2核CPU，那么CLR线程池的容量默认上限便是1000，也就是说，它最多可以管理1000个线程同时运行——很多情况下这已经是一个很可怕的数字了，如果您觉得这还不够，那么就应该考虑一下您的实现方式是否可以改进了。 对于ASP.NET应用程序来说，CLR线程池容量代表了应用程序最多可以同时执行的请求数量。对于托管在IIS上的ASP.NET执行环境来说，这个值由全局配置决定。这个配置在machine.config文件中system.web/processModel节点中，为maxWorkerThreads属性，它决定了为单个处理器分配的线程数。如果这个值为40，且机器上拥有4个处理器（2 * 2CPU），那么这台机器目前的配置表示在同一时刻，ASP.NET可以同时处理160个请求。某些参考资料建议您将其修改为每处理器80-100个线程，这时您只要修改相应的属性值就可以了。 既然有最大值，也就相应有了最小值，它代表了CLR线程池“总是会保留”的最少线程数量。由于线程会占用资源，如在默认情况下，每个线程将获得1MB大小的栈空间3。所以如果在系统中保留太多空闲线程对资源也是一种浪费。因此，CLR线程池在使用大量线程处理完大量任务之后，也会逐步地释放线程，直至到达最小值。CLR线程池的最小线程数量确保了在任务数量较少的情况下，新来的任务可以立即执行，从而省去了创建新线程的时间。在普通应用程序中这个值为“处理器数 * 1”，而在ASP.NET应用程序中这个值配置在machine.config文件中system.web/processModel节点的minWorkerThreads属性中4。 在某些时候可能会遇到这样的情况：在一个瞬间忽然来大量任务，每个任务的执行时间说长不长说短不短，不过足以导致线程池快速分配数百个线程。如果这个峰值之后就一片平静，那么势必造成大量空闲的线程，这种开销对性能的损耗也非常明显。因此，CLR线程池限制了线程的创建速度不超过每秒2个。这样，即使在某个瞬时获得了大量的任务，CLR线程池也可以使用相对较少的线程来完成所有工作5。 但是，还有一种情况也值得考虑。例如，对于一个比较繁忙的Web应用程序来说，一打开便会涌入大量的连接。由于线程的创建速度有限，因此可以执行的请求数量也只能慢慢增加。对于这种您预料到会产生大量线程，而且忙碌状况会持续一段时间的情况，限制线程的创建速度反而会带来损伤效率。这时，您就可以手动设置CLR线程池的最小线程数量。如果此时CLR线程池中拥有的线程数量较少，那么系统就会立即创建一定数量的线程来达到这个最小值。设置和获取CLR线程池最小线程数量的接口为: public static class ThreadPool { public static void GetMinThreads(out int workerThreads, out int completionPortThreads); public static bool SetMinThreads(int workerThreads, int completionPortThreads); } 这两个接口的作用和使用方式应该足够明显了（不理解的话可以查阅MSDN），其中workerThreads参数便是CLR线程池的最小线程数，而completionPortThreads涉及到我们下次要讨论IO线程池，在此就不多作展开了。除了设置和读取CLR最小线程数的方法之外，ThreadPool还包含这些接口： public static class ThreadPool { public static void GetMaxThreads(out int workerThreads, out int completionPortThreads); public static bool SetMaxThreads(int workerThreads, int completionPortThreads); public static void GetAvailableThreads(out int workerThreads, out int completionPortThreads); } 值得注意的是，无论是设置还是获取到的这些数值，都与处理器数量没有任何关系了。也就是说，在一台2 * 2CPU的机器上运行一个普通的.NET应用程序时： 1.调用GetMaxThreads方法将获得1000，表示CLR线程池最大容量为1000（250 * 4），而不是250。 2.调用SetMinThreads并传入100，表示CLR线程池所拥有的最小线程数量为100，而不是400（100 * 4）。 3.对于CLR线程池的简单描述就暂时先到这里了。如果您还有什么疑问请提出，我会加以补充。 独立线程池: 上次我们讨论到，在一个.NET应用程序中会有一个CLR线程池，可以使用ThreadPool类中的静态方法来使用这个线程池。我们只要使用QueueUserWorkItem方法向线程池中添加任务，线程池就会负责在合适的时候执行它们。我们还讨论了CLR线程池的一些高级特性，例如对线程的最大和最小数量作限制，对线程创建时间作限制以避免突发的大量任务消耗太多资源等等。 那么.NET提供的线程池又有什么缺点呢？有些朋友说，一个重要的缺点就是功能太简单，例如只有一个队列，没法做到对多个队列作轮询，无法取消任务，无法设定任务优先级，无法限制任务执行速度等等。不过其实这些简单的功能，倒都可以通过在CLR线程池上增加一层（或者说，通过封装CLR线程池）来实现。例如，您可以让放入CLR线程池中的任务，在执行时从几个自定义任务队列中挑选一个运行，这样便达到了对多个队列作轮询的效果。因此，在我看来，CLR线程池的主要缺点并不在此。 我认为，CLR线程池的主要问题在于“大一统”，也就是说，整个进程内部几乎所有的任务都会依赖这个线程池。如前篇文章所说的那样，如Timer和WaitForSingleObject，还有委托的异步调用，.NET框架中的许多功能都依赖这个线程池。这个做法是合适的，但是由于开发人员对于统一的线程池无法做到精确控制，因此在一些特别的需要就无法满足了。举个最常见例子：控制运算能力。什么是运算能力？那么还是从线程讲起吧1。 我们在一个程序中创建一个线程，安排给它一个任务，便交由操作系统来调度执行。操作系统会管理系统中所有的线程，并且使用一定的方式进行调度。什么是“调度”？调度便是控制线程的状态：执行，等待等等。我们都知道，从理论上来说有多少个处理单元（如2 * 2 CPU的机器便有4个处理单元），就表示操作系统可以同时做几件事情。但是线程的数量会远远超过处理单元的数量，因此操作系统为了保证每个线程都被执行，就必须等一个线程在某个处理器上执行到某个情况的时候，“换”一个新的线程来执行，这便是所谓的“上下文切换（context switch）”。至于造成上下文切换的原因也有多种，可能是某个线程的逻辑决定的，如遇上锁，或主动进入休眠状态（调用Thread.Sleep方法），但更有可能是操作系统发现这个线程“超时”了。在操作系统中会定义一个“时间片（timeslice）”2，当发现一个线程执行时间超过这个时间，便会把它撤下，换上另外一个。这样看起来，多个线程——也就是多个任务在同时运行了。 值得一提的是，对于Windows操作系统来说，它的调度单元是线程，这和线程究竟属于哪个进程并没有关系。举个例子，如果系统中只有两个进程，进程A有5个线程，而进程B有10个线程。在排除其他因素的情况下，进程B占有运算单元的时间便是进程A的两倍。当然，实际情况自然不会那么简单。例如不同进程会有不同的优先级，线程相对于自己所属的进程还会有个优先级；如果一个线程在许久没有执行的时候，或者这个线程刚从“锁”的等待中恢复，操作系统还会对这个线程的优先级作临时的提升——这一切都是牵涉到程序的运行状态，性能等情况的因素，有机会我们在做展开。 现在您意识到线程数量意味着什么了没？没错，就是我们刚才提到的“运算能力”。很多时候我们可以简单的认为，在同样的环境下，一个任务使用的线程数量越多，它所获得的运算能力就比另一个线程数量较少的任务要来得多。运算能力自然就涉及到任务执行的快慢。您可以设想一下，有一个生产任务，和一个消费任务，它们使用一个队列做临时存储。在理想情况下，生产和消费的速度应该保持相同，这样可以带来最好的吞吐量。如果生产任务执行较快，则队列中便会产生堆积，反之消费任务就会不断等待，吞吐量也会下降。因此，在实现的时候，我们往往会为生产任务和消费任务分别指派独立的线程池，并且通过增加或减少线程池内线程数量来条件运算能力，使生产和消费的步调达到平衡。 使用独立的线程池来控制运算能力的做法很常见，一个典型的案例便是SEDA架构：整个架构由多个Stage连接而成，每个Stage均由一个队列和一个独立的线程池组成，调节器会根据队列中任务的数量来调节线程池内的线程数量，最终使应用程序获得优异的并发能力。 在Windows操作系统中，Server 2003及之前版本的API也只提供了进程内部单一的线程池，不过在Vista及Server 2008的API中，除了改进线程池的性能之外，还提供了在同一进程内创建多个线程池的接口。很可惜，.NET直到如今的4.0版本，依旧没有提供构建独立线程池的功能。构造一个优秀的线程池是一件相当困难的事情，幸运的是，如果我们需要这方面的功能，可以借助著名的SmartThreadPool，经过那么多年的考验，相信它已经足够成熟了。如果需要，我们还可以对它做一定修改——毕竟在不同情况下，我们对线程池的要求也不完全相同。 IO线程池: IO线程池便是为异步IO服务的线程池。 访问IO最简单的方式（如读取一个文件）便是阻塞的，代码会等待IO操作成功（或失败）之后才继续执行下去，一切都是顺序的。但是，阻塞式IO有很多缺点，例如让UI停止响应，造成上下文切换，CPU中的缓存也可能被清除甚至内存被交换到磁盘中去，这些都是明显影响性能的做法。此外，每个IO都占用一个线程，容易导致系统中线程数量很多，最终限制了应用程序的伸缩性。因此，我们会使用“异步IO”这种做法。 在使用异步IO时，访问IO的线程不会被阻塞，逻辑将会继续下去。操作系统会负责把结果通过某种方法通知我们，一般说来，这种方式是“回调函数”。异步IO在执行过程中是不占用应用程序的线程的，因此我们可以用少量的线程发起大量的IO，所以应用程序的响应能力也可以有所提高。此外，同时发起大量IO操作在某些时候会有额外的性能优势，例如磁盘和网络可以同时工作而不互相冲突，磁盘还可以根据磁头的位置来访问就近的数据，而不是根据请求的顺序进行数据读取，这样可以有效减少磁头的移动距离。 Windows操作系统中有多种异步IO方式，但是性能最高，伸缩性最好的方式莫过于传说中的“IO完成端口（I/O Completion Port，IOCP）”了，这也是.NET中封装的唯一异步IO方式。大约一年半前，老赵写过一篇文章《正确使用异步操作》，其中除了描述计算密集型和IO密集型操作的区别和效果之外，还简单地讲述了IOCP与CLR交互的方式，摘录如下： 当我们希望进行一个异步的IO-Bound Operation时，CLR会（通过Windows API）发出一个IRP（I/O Request Packet）。当设备准备妥当，就会找出一个它“最想处理”的IRP（例如一个读取离当前磁头最近的数据的请求）并进行处理，处理完毕后设备将会（通过Windows）交还一个表示工作完成的IRP。CLR会为每个进程创建一个IOCP（I/O Completion Port）并和Windows操作系统一起维护。IOCP中一旦被放入表示完成的IRP之后（通过内部的ThreadPool.BindHandle完成），CLR就会尽快分配一个可用的线程用于继续接下去的任务。 不过事实上，使用Windows API编写IOCP非常复杂。而在.NET中，由于需要迎合标准的APM（异步编程模型），在使用方便的同时也放弃一定的控制能力。因此，在一些真正需要高吞吐量的时候（如编写服务器），不少开发人员还是会选择直接使用Native Code编写相关代码。不过在绝大部分的情况下，.NET中利用IOCP的异步IO操作已经足以获得非常优秀的性能了。使用APM方式在.NET中使用异步IO非常简单，如下： static void Main(string[] args) { WebRequest request = HttpWebRequest.Create(&quot;http://www.cnblogs.com&quot;); request.BeginGetResponse(HandleAsyncCallback, request); } static void HandleAsyncCallback(IAsyncResult ar) { WebRequest request = (WebRequest)ar.AsyncState; WebResponse response = request.EndGetResponse(ar); // more operations... } BeginGetResponse将发起一个利用IOCP的异步IO操作，并在结束时调用HandleAsyncCallback回调函数。那么，这个回调函数是由哪里的线程执行的呢？没错，就是传说中“IO线程池”的线程。.NET在一个进程中准备了两个线程池，除了上篇文章中所提到的CLR线程池之外，它还为异步IO操作的回调准备了一个IO线程池。IO线程池的特性与CLR线程池类似，也会动态地创建和销毁线程，并且也拥有最大值和最小值（可以参考上一篇文章列举出的API）。 只可惜，IO线程池也仅仅是那“一整个”线程池，CLR线程池的缺点IO线程池也一应俱全。例如，在使用异步IO方式读取了一段文本之后，下一步操作往往是对其进行分析，这就进入了计算密集型操作了。但对于计算密集型操作来说，如果使用整个IO线程池来执行，我们无法有效的控制某项任务的运算能力。因此在有些时候，我们在回调函数内部会把计算任务再次交还给独立的线程池。这么做从理论上看会增大线程调度的开销，不过实际情况还得看具体的评测数据。如果它真的成为影响性能的关键因素之一，我们就可能需要使用Native Code来调用IOCP相关API，将回调任务直接交给独立的线程池去执行了。 我们也可以使用代码来操作IO线程池，例如下面这个接口便是向IO线程池递交一个任务： public static class ThreadPool { public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped); } NativeOverlapped包含了一个IOCompletionCallback回调函数及一个缓冲对象，可以通过Overlapped对象创建。Overlapped会包含一个被固定的空间，这里“固定”的含义表示不会因为GC而导致地址改变，甚至不会被置换到硬盘上的Swap空间去。这么做的目的是迎合IOCP的要求，但是很明显它也会降低程序性能。因此，我们在实际编程中几乎不会使用这个方法。 线程池的相关实验。级注意事项: 小白写的参考实例: 下载实例 参考实例效果图: 参考实例代码图: 注:如果有不懂的地方可以联系小白，在博客的关于里面可以找到小白的联系方式！ 送上一句晚安心语: 【遥遥的梦亮起一盏灯，听我心愿一声声，但愿你平安一程又一程，但愿所有的美好装满您的梦，祝您今晚安然入睡，好梦！】]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号量机制---线程池准备工作，]]></title>
    <url>%2F2018%2F09%2F19%2FThread%2FThreadPool%2F</url>
    <content type="text"><![CDATA[信号量机制: ★★★★★★★★★★★★★★★★★★★★★★ 1. 线程池概念 ★★★★★★★★★★★★★★★★★★★★ 其实“线程池”就是用了存放“线程”的对象池。 在程序中，如果某个创建某种对象所需要的代价太高，同时这个对象又可以返复使用。那么我们往往就会准备一个容器，用来保存一批这样的对象，于是乎，我们想要用这种对象时，就不需要每次去创建一个，而直接从容器中取出一个现场的对象就可以了，由于节省了创建对象的开销，程序性能自然就上升了，这个容器就是池。很容易理解的是，因为有了对象池，因此在用完对象之后必须有一个“归还”的动作，这样便可以把对象放回池中，下次需要的时候就可以再次拿出来使用了。 了解线程池之前：先要了解:概念: 1.0线程和进程的关系以及优缺点 windows系统是一个多线程的操作系统，一个程序至少有一个进程，一个进程至少有一个线程，进程是线程的容器，一个C#客户端程序开始于一个单独的线程， CLR(公共语言运行库)为该进程创建了一个线程，该线程称为主线程，例如当我们创建一个C#控制台程序，程序的入口是Main()函数，Main()函数是始于一个主 线程的，它的功能主要是产生新的线程和执行程序，C#是一门支持多线程的编程语言，通过Thread类创建子线程，引用using System.Threading命名空间。 多线程的优点: 1.多线程可以提高CPU的利用率，因为当一个线程处于等待状态的时候，CPU会去执行另外的线程。 2.提高了CPU的利用率，就可以直接提高程序的整体执行速度。 多线程的缺点: 1.线程开的越多，内存占用越大。 2.协调和管理代码的难度加大，需要CPU时间跟踪线程。 3.线程之间对资源的共享可能会产生不可预知的问题。 1.1前台线程和后台线程区别： Thread.IsBackground = false;//false:设置为前台线程，系统默认为前台线程 线程是寄托在进程上的，进程都结束了，线程也就不复存在了！ 只要有一个前台线程为退出，进程就不会终止！即说的就是程序不会关闭！(即在资源管理器中可以看到进程未结束) 1.2首先使用new Thread()创建出新的线程，然后调用Strat方法使得线程进入就绪状态，得到系统资源后就执行，在执行 过程中可能有等待、休眠、死亡和阻塞四种状态。正常执行结束时间片后返回到就绪状态。如果调用Suspend方法会进入 等待状态，调用Sleep或者遇到进程同步使用的锁机制而休眠等待，具体过程如下图所示。线程的基本操作: 线程和其它常见的类一样，有着很多属性和方法，参考下表： 属性 说明 CurrentThread 获取当前正在运行的线程 IsAlive 获取一个值，该值指示当前线程的执行状态 Name 获取或设置线程名称 Priority 获取或设置一个值，该值指示线程的调度优先级 ThreadState 获取一个值，该值包括当前线程的状态 方法 说明 Abort 在调用此方法的线程上引发ThreadAbortException, 以开始终止此线程的过程。调用此方法通常会终止线程。 Join 阻止调用线程，直到某个线程终止时为止 ResetAbort 取消为当前线程请求的Abort Resume 继续已挂起的线程 Sleep 将当前线程阻止指定的毫秒数 Start 使线程被安排进行执行 Suspent 挂起线程，或者如果线程已挂起，则不起作用 2.1线程的相关属性的使用 实例里面有详细的类，进行说明。备注很清晰！ 2.2线程的优先级 如果在应用程序中有多个线程在运行，但一些线程比另一个线程重要，这种情况下可以在一个进程中为不同的线程指定不同的优先级，线程的优先级可以通过Thread类Priority属性设置，Priority属性是一个ThreadPriority型枚举，列举了5个优先等级：AboveNormal、BelowNormal、Highest、Lowest、Normal。公共语言库默认是Normal类型的：如下 优先级值 说明 AboveNormal 可以将Thread安排在具有Highest优先级的线程之后，在具有Normal优先级的线程之前 BelowNormal 可以将Thread安排在具有Normal优先级的线程之后，在具有Lowest优先级的线程之前 Highest 可以将Thread安排在具有任何其他优先级的线程之前 Lowest 可以将Thread安排在具有任何其他优先级的线程之后 Normal 可以将Thread安排在具有AboveNormal优先级的线程之后，在具有BelowNormal优先级的线程之前，默认情况下，线程具有 Normal优先级 线程的优先级： 优先级越高表示CPU分配给该线程的时间片越多，执行时间就多， 优先级越低表示CPU分配给该线程的时间片越少，执行时间就少。 线程同步: 3.1什么是线程安全： 线程安全是指在当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完成，其他线程才可使用，不会出现数据不一致或者数据污染。 线程有可能和其他线程共享一些资源，比如，内存，文件，数据库等，当多个线程同时读写同一份共享资源的时候，可能会引起冲突，这时候，我们需要引入线程”同步”机制，即各线程之间要有个先来后到，不能一窝蜂挤上去抢作一团，线程同步的真实意思和字面意思恰好相反，线程同步的真实意思，其实是：”排队”，几个线程之间要排队，一个一个对共享资源进行操作。而不是同时进行操作。 3.2使用Monitor类实现线程同步 Lock关键字是Monitor的一种替换用法，lock在IL代码中会被翻译成Monitor.lock(obj){//代码块 } 就等同与 Monitor.Enter(obj);//代码块Monitor.Exit(obj); Monitor的常用属性和方法： Enter(Object)在指定对象上获取排他锁。 Exit(Object)释放指定对象上的排他锁。 Pulse 通知等待队列中的线程锁定对象状态的更改。 PulseAll 通知所有的等待线程对象状态的更改。 TyEnter(Object) 试图获取指定对象的排他锁。 TyEnter(Object,Boolean)尝试获取指定对象上的排他锁，并自动设置一个值，指示是否得到了该锁。 Wait(Object)释放对象上的锁并阻止当前线程，直到它重新获取该锁。 常用的方法有两个，Monitor.Enter(Object)方法是获取锁，Monitor.Exit(Object)的方法是释放锁，这结束Monitor最常用的两个方法，在使用过程中为了避免获取锁之后因为异常，致锁无法释放，所以需要在try{}catch{}之后的finally{}结构体中释放锁(Monitor.Exit())。 3.3Monitor.Wait是让当前进程睡眠在临界资源上并释放独占锁，它只是1等待，并不退出，当等待结束，就要继续执行剩下的代码。 使用Mutex类实现线程同步: Mutes的突出特点是可以垮应用程序域边界对资源进行独占访问，即可以用于同步不同进程中的线程，这种功能当然这是以牺牲更多的系统资源为代价的。 主要常用的两个方法： public virtual bool WaitOne() 阻止当前线程，直到当前 System.Threading.WaitHandle 收到信号获取互斥锁。 public void ReleaseMutex() 释放 System.Threadingg.Mutex 一次。 线程池: 上面介绍了介绍平时用到的大多数的多线程的例子，但在实际开发中使用的线程往往是最大的和更为复杂的，这时，每天都创建线程，启动线程。从性能上来讲，这样做并不理想,(因为每使用一个线程就要创建一个1，需要占用系统开销)；从操作上来讲，每次都要启动，比较麻烦，为此引入的线程池的概念。 好处: 1.减少在创建和销毁线程上所花的时间以及系统资源的开销 2.如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存 以及“过度切换”。 在什么情况下使用线程池: 1.单个任务处理的时间比较短 2.需要处理的任务的数量大 线程池最多管理线程梳理=”处理器数*250”。也就是说，如果您的机器为2个2核 CPU,那么CLR线程池的容量默认上限便是1000，通过线程池创建的线程默认为 后台线程，优先级默认为Normal。 小白写的参考实例: 下载实例 参考实例效果图: 参考实例代码图: 注:如果有不懂的地方可以联系小白，在博客的关于里面可以找到小白的联系方式！ 送上一句晚安心语: 【遥遥的梦亮起一盏灯，听我心愿一声声，但愿你平安一程又一程，但愿所有的美好装满您的梦，祝您今晚安然入睡，好梦！】]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号量机制---同步，]]></title>
    <url>%2F2018%2F09%2F14%2FThread%2FInsert1%2F</url>
    <content type="text"><![CDATA[信号量机制: ★★★★★★★★★★★★★★★★★★★★★★ 1. 什么是同步 ★★★★★★★★★★★★★★★★★★★★ 所谓线程同步，就是多个线程之间在某个对象上执行等待(也可以理解为锁定该对象)，直到该对象被解除锁定。C#中对象的类型分为引用类型和值类型。CLR这两种类型上的等待是不一样的，我们可以简单的离职为在CLR中，值类型是不能被锁定的，也即；不能在一个值类型对象上执行等待。而在引用类型上的等待机制，则分为两类：锁定和信号同步。锁定，使用关键字lock和类型Monitor。两者没有使之区别，前者其实是后者的语法糖，这是最常用的同步技术。 注：CLR（common language runtime）即公共语言运行库，是托管代码执行核心中的引擎。CLR为托管代码提供各种服务，如跨语言集成、跨语言异常处 理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。使CLR能够向托管代码提供服务，语言编译器必须生成一些元数 据来描述代码中的类型、成员和引用。 现在说这么理论，让小白用灵魂画手的技术，来画一副。信号同步机制中涉及的类型都继承自抽象类WaitHandle,这些类型有EventWaitHandle(类型化为 AutoResetEvent、ManualResetEvent)和Semaphore以及Mutex。见图(后来发现什么灵魂画手都是假的，我还是用公司的流程平台画吧) EventWaitHandle(子类为AutoResetEvent、ManualResetEvent)和Semaphore以及Mutex都继承自WaitHandle,所以它们底层的原理是一致，维护的都是一个系 统内核句柄。不过我们仍需简单的区分下这三类类型: 1.EventWaitHandle,维护一个由内核产生的布尔类型对象(我们称之为“阻滞状态”)，如果其值为false,那么在它上面等待的线程就阻塞。可以调用类型的Set方法将其值设置为true,解除阻塞。EventWaitHandle类型的两个子类AutoReseEvent和ManualResetEvent,它们的区别并不打，本建议接下来会针对它们阐述如何正确使用信号量。 2.Semaphore,维护一个由内核产生的整数变量，如果其值为0，则在它上面等待的线程就阻塞，其值大于0，就解除阻塞，同时，每解除阻塞一个线程，其值就减1。 3.EventWaitHandle 和Semaphore提供的都是单应用程序域内的线程同步功能，Mutex则不同它为我们提供了跨应用程序域阻塞和解除阻塞线程的能力。 实例的运行过程: 这是一个简单的Winfrom窗体程序，其中一个按钮负责开启一个新的线程，还有一个按钮负责给刚开启的那个线程发送信号，现在详细解释这里面发生的事情。 AutoResetEvent autoResetEvent=new AutoResetEvent(false); 这段代码创建了一个同步类型对象autoResetEvent，它设置自己的默认阻滞状态false。这意味着任何在它上面进行等待的线程将会被阻滞，所谓进行等待，就是线程中的应用: autoResetEvent.WaitOne(); 这说明work开始在autoResetEvnet上等待任何其他地方给它的信号，信号来了，则work开始继续工作，否则就一直等着(即阻滞)。接下来我们看到主线程中(本例中即ui线程它相对线程work来说，就是一个“另外的线程”)； autoResetEvent.Set(); 主线程通过上面这句代码负责向在autoResetEvent上等待的线程work上下文发送信号，即将work的阻滞状态设置为true，work接收到这个信号，开始继续工作。这个例子很简单，但是确说明了。信号机制的工作原理。 注：当在编写程序中遇到，运行程序时，遇到：“System.InvalidOperationException:“线程间操作无效: 从不是创建控件“label1”的线程访问它。”这个错误的时候请加上”：C# WinForm开发中，这是一个比较常见的异常：线程间操作无效，从不是创建控件“xxx”的线程访问它。这个异常来源于.NET2的一个限制：工作线程不能访问窗口线程创建的控件。解决方法主要有两种，一种是在窗口线程中设置CheckForIllegalCrossThreadCalls = false ；另一种方式比较麻烦，使用委托的方式调用Invoke方法。小编用了一种比较简单的办法。 2：AutoResetEvent 和 ManualResetEvent的区别: AutoResetEvent 和 ManualResetEvent有这样的区别：前者在发送信号完毕后(即调用Set方法)，自动将自己的阻滞状态设置为false,而后者需进行手动设定。可以通过一个例子来说明这种区别： 1.AutoResetEvent ：在发送信号完毕就在内核中自动将自己的状态设置回false,但是可以重新启动线程。 2.ManualResetEvent：在发送信号完毕时，线程一和线程二同时收到信号，同时执行，到释放，当线程释放过后，点击事件是不可以重新启动线程。 小白写的参考实例: 下载实例 参考实例效果图: 参考实例代码图：: 注:如果有不懂的地方可以联系小白，在博客的关于里面可以找到小白的联系方式！ 送上一句晚安心语: 【你要储存你的可爱 眷顾你的善良 变得勇敢 当这个世界越来越坏时 只希望你能越来越好。】]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号量机制---互斥，]]></title>
    <url>%2F2018%2F09%2F05%2FThread%2FInsert%2F</url>
    <content type="text"><![CDATA[信号量机制: ★★★★★★★★★★★★★★★★★★★★★★ 1. 什么是互斥 ★★★★★★★★★★★★★★★★★★★★ 多进程环境下，若一个进程已进入临界区访问临界资源时，其他进程不得进入临界区。该进程独自享有临界区全部临界资源，对于其他进程具有强烈的排斥性。这种只允许一个执行流访问临界资源的情形称为互斥。 信号量(Semaphore)机制: 信号量也算是个鼎鼎大名的东西吧，提到互斥量总会说起信号量，二者的差别很简单，互斥量，临界区是用于保护”一个”需要被互斥访问的资源，这个资源同时只有一个线程能被访问：而信号量可以被用于管理“资源池”。在.Net中Semaphore类就是对Windows信号量的封装.Semaphore的构造函数:Semaphore(Int32, Int32) 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数。 Semaphore(Int32, Int32, String) 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口,数，可以选择指定系统信号量对象的名称。 Semaphore(Int32, Int32, String, Boolean) 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口,数，还可以选择指定系统信号量对象的名称，以及指定一个变量来接收指示是否创建了新系统信号量的值。 Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity) 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数，可以选择指定系统信号量对象的名称，指定一个变量来接收指示是否创建新系统信号量的值，以及指定系统信号量的安全访问控制。 如果想学习Semaphore的方法: 链接地址 小白写的参考实例: 下载实例 参考实例效果图：: 参考实例代码图: 注:如果有不懂的地方可以联系小白，在博客的关于里面可以找到小白的联系方式！ 送上一句晚安心语: 【轻轻的闭上眼睛，慢慢的酝酿心情，将白天所有烦恼不快撒向天空，随着流星的坠落一起沉淀，愿今夜有个好梦，晚安！】]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql server --ROW_NUMBER函数使用]]></title>
    <url>%2F2018%2F08%2F31%2FSQL%20Server%2FRow_number%2F</url>
    <content type="text"><![CDATA[ROW_NUMBER函数说明: 返回结果集分区内行的序列号，每个分区的第一行从1开始。 ROW_NUMBER()我对此的理解: 利用此函数可以为表中的某个字段建立序列，从1开始。就是说，根据已存在的某列，利用此函数可建立一新列，新列是数字，按照已存在列的顺序从1开始。 上面说的可能不是很清楚，结合下面这个例子来看吧！ 例如: select t.,d.TZcName,d.TGetDate,d.TZcNum from (select g.,a.SysId,a.MemberName,a.NowCompanyName,a.NowCompanyId,a.MSex, a.MBirthday,a.MIDNumber,a.JoinWorkDate,a.EntryDate,a.JzzNum,a.MLandscape, a.NowPostJobName,a.NowPostName, a.IsDel from sz_hr_Members a left join(select * from ( select MemberSysId,Degree,Discipline,XueWei,EndDate,School, ROW_NUMBER()over(partition by MemberSysId order by EndDate desc ) as stu from sz_hr_Education)a where a.stu&lt;=1 )as g on a.SysId=g.MemberSysId) t left join sz_hr_Titles d on t.SysId=d.MemberSysId where t.IsDel=0 and t.SysId=@SysId 上述sql主要功能: select * from (select MemberSysId,Degree,Discipline,XueWei,EndDate,School,ROW_NUMBER() over(partition by MemberSysId order by EndDate desc) as stu from sz_hr_Education)a where a.stu&lt;=1 这里面的功能是当一个人有多条学历的时候，取出每个人相对应的最高学历 --查询语句需要根据自己的 业务功能来写，请记得告诉自己sql语句本身就是一种对逻辑思维的锻炼。加油~ 送上一句晚安心语: 【放弃与放手的区别：放弃是牺牲本来属于你的，放手是放下那些从来不是你的。】]]></content>
      <categories>
        <category>Sql server</category>
      </categories>
      <tags>
        <tag>Sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql server --视图使用]]></title>
    <url>%2F2018%2F08%2F31%2FSQL%20Server%2FViewIn%2F</url>
    <content type="text"><![CDATA[视图简介：: 视图可以看作定义在SQL Server上的虚拟表。视图正如其名字的含义一样，是另一种查看数据的入口。 常规视图本身并不存储实际的数据，而仅仅是由SELECT语句组成的查询定义的虚拟表 。 从数据库系统内部来看，视图是由一张或多张表中的数据组成的，从数据库系统外部来看，视图就如同一张表一样，对表能够进行的一般操作都可以应用于视图。 例如查询，插入，修改，删除操作等，但插入、修改、删除等的操作其实对于原始数据表的操作。 视图的作用: 1、视图隐藏了底层的表结构，简化了数据访问操作，客户端不再需要知道底层表的结构及其之间的关系。 2、视图提供了一个统一访问数据的接口。（即可以允许用户通过视图访问数据的安全机制，而不授予用户直接访问底层表的权限） 3、从而加强了安全性，使用户只能看到视图所显示的数据。 4、视图还可以被嵌套，一个视图中可以嵌套另一个视图。 例如：视图(当数据里面存在这跟新数据，不存在这添加数据)一般用于导入数据: BEGIN TRANSACTION IF EXISTS ( SELECT 1 FROM A WHERE IDNumber=@IDNumber and IsDel=@IsDel and DepSysId=@DepSysId ) –判断这条数据是否存在 UPDATE A SET SysId=@SysId,CampusSysId=@CampusSysId,DepSysId=@DepSysId, –存在的时候更新数据 DepName=@DepName,UserName=@UserName,People=@People,Birthday=@Birthday, Province=@Province,City=@City, Sex=@Sex,Landscape=@Landscape,BestEdu=@BestEdu,EngLevel=@EngLevel, Agreement=@Agreement, IDNumber=@IDNumber,Recommended=@Recommended,MedicalReport=@MedicalReport, School=@School, Professional=@Professional,MobileTel=@MobileTel,IsDel=@IsDel, OperateUser=@OperateUser, CreatedDate=@CreatedDate,OperateUserName=@OperateUserName WHERE IDNumber=@IDNumber and IsDel=@IsDel and DepSysId=@DepSysId; ELSE INSERT A (SysId,CampusSysId,DepSysId,DepName,UserName, –不存在的时候添加数据 People,Birthday,Province,City,Sex,Landscape,BestEdu,EngLevel,Agreement,Recommended, MedicalReport,School,Professional,MobileTel,IDNumber,IsDel,OperateUser,CreatedDate, OperateUserName) VALUES (@SysId,@CampusSysId,@DepSysId,@DepName,@UserName,@People,@Birthday,@Province, @City,@Sex,@Landscape,@BestEdu,@EngLevel,@Agreement,@Recommended,@MedicalReport, @School, @Professional,@MobileTel,@IDNumber,@IsDel,@OperateUser,@CreatedDate, @OperateUserName); COMMIT 例如:创建一个简单的视图使用情况: if exists(select from sysobjects where id=OBJECT_ID(N’v_Stu_Cou_Par’) and objectproperty(id,N’IsView’)=1) drop view v_Stu_Cou_Par –删除视图 go create view dbo.v_Stu_Cou_Par –创建视图 as select S_Id,S_StuNo,S_Name,S_Sex,S_Height,S_BirthDate,c.C_Id,c.C_Name from Student s1 left join Course c on s1.C_S_Id=c.C_Id where s1.C_S_Id is not null union all select S_Id,S_StuNo,S_Name,S_Sex,S_Height,S_BirthDate,c.C_Id,c.C_Name from Student_back s2 left join Course c on s2.C_S_Id=c.C_Id where s2.C_S_Id is not null go select from v_Stu_Cou_Par –使用视图查询 视图的主要功能: 主要功能，保证数据的唯一性，提高导入的效率，和防止数据重复存在。事务就是绑定在一起作为一个逻辑工作单元的Sql语句分组。要么全部执行，要么全部不执行。 送上一句晚安心语: 【做人，就该坚强，在困难面前，不投降，在责任面前，不逃避。遇山，找路，遇水，架桥。】]]></content>
      <categories>
        <category>Sql server</category>
      </categories>
      <tags>
        <tag>Sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql server --Convert 函数的使用]]></title>
    <url>%2F2018%2F08%2F30%2FSQL%20Server%2FConvert%2F</url>
    <content type="text"><![CDATA[Convert()函数说明: 函数可以用不同的格式显示日期/时间数据，可以根据所需功能，进行不同的调整。 例如: select(convert(datetime,left(‘所需转换的字段名称’,20)))as ‘别名’ from 表名 where IsDel=0 业务功能:需要根据最近的功能进行不同的调整。如果你是初学者，建议最好不要复制，因为代码的世界，是需要自己一点一点的积累。 送上一句晚安心语:【向日葵经历了风雨，站在阳光下更显灿烂；扑朔迷离的希望，出现时才令人惊喜。保持乐观的心态，走着走着，天就亮了，幸福也就跟着来了。】]]></content>
      <categories>
        <category>Sql server</category>
      </categories>
      <tags>
        <tag>Sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql server -- GROUP BY 函数的使用]]></title>
    <url>%2F2018%2F08%2F27%2FSQL%20Server%2FGroupby%2F</url>
    <content type="text"><![CDATA[GROUP BY函数说明: 主要用于分组。对一组，或多组数据按照自己的所需功能进行分组。例如: select from( select from ‘表明’ a left join ‘表明’ s on ‘字段明’= ‘‘字段明’’) as c left join (select MemberSysId,max(EndDate),School,Discipline,Degree –查询出来的最大时间 from sz_hr_Education s GROUP BY ‘字段明1’,‘‘字段明2’,‘‘字段明3’,‘‘字段明4’’ –按照多个分组 ) as d on ‘字段明’=‘字段明’ and c.IsDel=0 group by d.MemberSysId –条件，然后在按照一层，进行分组。 业务功能: 这里的功能主要根据自己的业务需求来的，小白是给自己写过的东西，解释，总结一下。分享一下自己的经验。这样可以少走很多弯路。 送上一句晚安心语:【不要与他人比较，懂得欣赏自己的生活，才能让自己活得轻松许多，也更容易找到幸福的入口。生命是自己的，生活也是自己的，不要把太多的时间浪费在和别人的对比上。每个人都有令人羡慕的东西，也有自己缺憾的东西，没有谁能事事如意。】]]></content>
      <categories>
        <category>Sql server</category>
      </categories>
      <tags>
        <tag>Sql server</tag>
      </tags>
  </entry>
</search>
